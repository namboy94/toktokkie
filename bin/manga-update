"""LICENSE
Copyright 2015 Hermann Krumrey <hermann@krumreyh.com>

This file is part of toktokkie.

toktokkie is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

toktokkie is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with toktokkie.  If not, see <http://www.gnu.org/licenses/>.
LICENSE"""

import os
import argparse
from colorama import Fore, Style
from puffotter.init import cli_start, argparse_add_verbosity
from toktokkie import Directory, sentry_dsn
from toktokkie.exceptions import MissingMetadata, InvalidMetadata
from toktokkie.metadata.Manga import Manga
from toktokkie.metadata.components.enums import MediaType, MangaIdType
from manga_dl.scrapers.mangadex import MangaDexScraper


def main(args: argparse.Namespace):
    """
    The main function of this script
    :param args: The command line arguments
    :return: None
    """
    scraper = MangaDexScraper()

    for path in args.directories:
        try:
            directory = Directory(path)
            print(directory.metadata.name)

            metadata = directory.metadata  # type: Manga
            if metadata.media_type() != MediaType.MANGA:
                print("Not a manga directory: {}".format(path))
                continue

            mangadex_id = metadata.ids.get(MangaIdType.MANGADEX)
            if mangadex_id is None or len(mangadex_id) == 0:
                print("No mangadex ID for {}".format(path))
                continue

            chapters = scraper.load_chapters(None, mangadex_id[0])
            main_chapters = []
            special_chapters = []

            for chapter in chapters:
                if "." in chapter.chapter_number:
                    special_chapters.append(chapter)
                else:
                    try:
                        int(chapter.chapter_number)
                        main_chapters.append(chapter)
                    except ValueError:
                        special_chapters.append(chapter)

            current_latest = len(os.listdir(metadata.main_path))
            main_chapters = list(filter(
                lambda x: int(x.chapter_number) > current_latest,
                main_chapters
            ))

            if not args.dry_run:
                directory.rename(noconfirm=True)
            maxchar = max(metadata.name)

            downloaded = []
            for c in main_chapters:

                if c.chapter_number in downloaded:
                    continue
                downloaded.append(c.chapter_number)

                name = "{}{} - Chapter {}.cbz".format(
                    maxchar,
                    metadata.name,
                    c.chapter_number.zfill(len(str(current_latest)))
                )
                dest = os.path.join(metadata.main_path, name)
                if not args.dry_run:
                    print("Downloading Chapter {}".format(c))
                    c.download(dest)
                else:
                    print("{}Found chapter: {}{}".format(
                        Fore.LIGHTYELLOW_EX,
                        c,
                        Style.RESET_ALL
                    ))

            if not args.dry_run:
                directory.rename(noconfirm=True)

        except MissingMetadata:
            print("{} has no metadata file.".format(path))
        except InvalidMetadata:
            print("{}'s metadata is invalid.".format(path))


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("directories", nargs="+",
                        help="The directories to update. "
                             "Files and directories that do not contain any "
                             "valid metadata configuration will be ignored.")
    parser.add_argument("--dry-run", action="store_true",
                        help="Does not download or rename anything")
    argparse_add_verbosity(parser)
    cli_start(
        main, parser, "Thanks for using toktokkie!", "toktokkie", sentry_dsn
    )
